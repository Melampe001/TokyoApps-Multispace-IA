# ============================================================================
# Imperial Cleaner Workflow - Enterprise Premium PR & Branch Management
# ============================================================================
#
# DESCRIPCIÃ“N:
# Este workflow implementa una soluciÃ³n de limpieza y gestiÃ³n automatizada de 
# Pull Requests siguiendo estÃ¡ndares enterprise premium con controles de 
# seguridad, trazabilidad y auditorÃ­a completos.
#
# FUNCIONALIDADES PRINCIPALES:
# 1. Cierre automÃ¡tico de PRs obsoletos o no deseados:
#    - PRs en estado draft
#    - PRs etiquetados como 'stale', 'wontfix', 'legacy'
#    - PRs inactivos por mÃ¡s de 72 horas
#
# 2. FusiÃ³n automÃ¡tica de PRs listos:
#    - Todos los checks de CI/CD pasados
#    - No son draft ni de dependabot
#    - Sin conflictos ni checks fallidos
#
# 3. GestiÃ³n especial de dependabot:
#    - Etiquetado con 'elite-review' para revisiÃ³n manual
#
# 4. AuditorÃ­a completa:
#    - Comentarios automÃ¡ticos en cada acciÃ³n
#    - Logs detallados de operaciones
#    - Trazabilidad de decisiones
#
# SEGURIDAD:
# - Permisos mÃ­nimos necesarios (principle of least privilege)
# - ValidaciÃ³n de estados antes de acciones destructivas
# - Control de errores robusto con manejo de fallos
#
# EJECUCIÃ“N:
# - Manual: workflow_dispatch
# - AutomÃ¡tica: 2 veces al dÃ­a (6:00 y 18:00 UTC)
# ============================================================================

name: Imperial Cleaner - PR Management

on:
  # EjecuciÃ³n programada: 2 veces al dÃ­a
  schedule:
    - cron: '0 6,18 * * *'  # 6:00 AM y 6:00 PM UTC
  
  # EjecuciÃ³n manual desde GitHub UI
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no hacer cambios reales)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

# Permisos mÃ­nimos requeridos siguiendo principio de menor privilegio
permissions:
  contents: write        # Para merge de PRs
  pull-requests: write   # Para cerrar, etiquetar y comentar PRs
  issues: write          # Para gestionar etiquetas

jobs:
  # =========================================================================
  # JOB: AuditorÃ­a y AnÃ¡lisis de PRs
  # Recopila informaciÃ³n sobre todos los PRs abiertos y determina acciones
  # =========================================================================
  analyze-prs:
    name: Analyze Pull Requests
    runs-on: ubuntu-latest
    outputs:
      prs-to-close: ${{ steps.analyze.outputs.prs-to-close }}
      prs-to-merge: ${{ steps.analyze.outputs.prs-to-merge }}
      dependabot-prs: ${{ steps.analyze.outputs.dependabot-prs }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PRs and determine actions
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            
            console.log('ðŸ” Starting Imperial Cleaner analysis...');
            console.log(`ðŸ“Š Dry Run Mode: ${isDryRun}`);
            console.log('='.repeat(60));
            
            // Obtener todos los PRs abiertos
            const { data: pullRequests } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`ðŸ“‹ Total open PRs: ${pullRequests.length}`);
            
            const prsToClose = [];
            const prsToMerge = [];
            const dependabotPrs = [];
            
            const now = new Date();
            const INACTIVE_THRESHOLD_MS = 72 * 60 * 60 * 1000; // 72 horas
            
            // Analizar cada PR
            for (const pr of pullRequests) {
              console.log(`\nðŸ”Ž Analyzing PR #${pr.number}: ${pr.title}`);
              console.log(`   Author: ${pr.user.login}`);
              console.log(`   Draft: ${pr.draft}`);
              console.log(`   Updated: ${pr.updated_at}`);
              
              const prNumber = pr.number;
              const isDraft = pr.draft;
              const author = pr.user.login;
              const updatedAt = new Date(pr.updated_at);
              const inactiveHours = Math.floor((now - updatedAt) / (1000 * 60 * 60));
              
              // Obtener etiquetas del PR
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber
              });
              
              const labelNames = labels.map(l => l.name);
              console.log(`   Labels: ${labelNames.join(', ') || 'none'}`);
              
              // Verificar si es de Dependabot
              const isDependabot = author === 'dependabot[bot]' || 
                                  author.includes('dependabot');
              
              if (isDependabot) {
                console.log(`   âš ï¸  Dependabot PR - marking for elite review`);
                dependabotPrs.push({
                  number: prNumber,
                  title: pr.title,
                  author: author
                });
                continue;
              }
              
              // REGLA 1: Cerrar PRs en draft
              if (isDraft) {
                console.log(`   âŒ CLOSE: PR is in draft state`);
                prsToClose.push({
                  number: prNumber,
                  title: pr.title,
                  reason: 'Draft PR - not ready for review',
                  inactive_hours: inactiveHours
                });
                continue;
              }
              
              // REGLA 2: Cerrar PRs con etiquetas especÃ­ficas
              const closeLabels = ['stale', 'wontfix', 'legacy'];
              const hasCloseLabel = labelNames.some(label => 
                closeLabels.includes(label.toLowerCase())
              );
              
              if (hasCloseLabel) {
                console.log(`   âŒ CLOSE: Has close label (${labelNames.join(', ')})`);
                prsToClose.push({
                  number: prNumber,
                  title: pr.title,
                  reason: `Tagged with: ${labelNames.filter(l => closeLabels.includes(l.toLowerCase())).join(', ')}`,
                  inactive_hours: inactiveHours
                });
                continue;
              }
              
              // REGLA 3: Cerrar PRs inactivos >72h
              if ((now - updatedAt) > INACTIVE_THRESHOLD_MS) {
                console.log(`   âŒ CLOSE: Inactive for ${inactiveHours} hours (>72h threshold)`);
                prsToClose.push({
                  number: prNumber,
                  title: pr.title,
                  reason: `Inactive for ${inactiveHours} hours (>72h threshold)`,
                  inactive_hours: inactiveHours
                });
                continue;
              }
              
              // REGLA 4: Verificar si estÃ¡ listo para merge automÃ¡tico
              try {
                // Obtener estado de checks del PR
                const { data: checks } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha,
                  per_page: 100
                });
                
                // Obtener estado combinado de commits
                const { data: commitStatus } = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: pr.head.sha
                }).catch(() => ({ data: { state: 'pending' } }));
                
                const allChecksPass = checks.check_runs.length === 0 || 
                  checks.check_runs.every(check => 
                    check.status === 'completed' && check.conclusion === 'success'
                  );
                
                const commitStatusSuccess = commitStatus.state === 'success' || 
                  commitStatus.state === 'pending' && checks.check_runs.length > 0;
                
                // Verificar si hay conflictos
                const mergeable = pr.mergeable !== false;
                const mergeableState = pr.mergeable_state;
                
                console.log(`   Checks: ${allChecksPass ? 'âœ…' : 'âŒ'}`);
                console.log(`   Status: ${commitStatus.state}`);
                console.log(`   Mergeable: ${mergeable}`);
                console.log(`   Mergeable State: ${mergeableState}`);
                
                // Si todos los checks pasan y no hay conflictos
                if (allChecksPass && commitStatusSuccess && mergeable && 
                    (mergeableState === 'clean' || mergeableState === 'unstable' || mergeableState === 'has_hooks')) {
                  console.log(`   âœ… MERGE: All conditions met for auto-merge`);
                  prsToMerge.push({
                    number: prNumber,
                    title: pr.title,
                    author: author,
                    sha: pr.head.sha
                  });
                } else {
                  console.log(`   â¸ï¸  SKIP: Not ready for auto-merge`);
                }
              } catch (error) {
                console.log(`   âš ï¸  Error checking PR status: ${error.message}`);
              }
            }
            
            // Resumen de acciones
            console.log('\n' + '='.repeat(60));
            console.log('ðŸ“Š ANALYSIS SUMMARY:');
            console.log(`   PRs to close: ${prsToClose.length}`);
            console.log(`   PRs to merge: ${prsToMerge.length}`);
            console.log(`   Dependabot PRs: ${dependabotPrs.length}`);
            console.log('='.repeat(60));
            
            // Guardar resultados para siguientes jobs
            core.setOutput('prs-to-close', JSON.stringify(prsToClose));
            core.setOutput('prs-to-merge', JSON.stringify(prsToMerge));
            core.setOutput('dependabot-prs', JSON.stringify(dependabotPrs));

  # =========================================================================
  # JOB: GestiÃ³n de PRs de Dependabot
  # Etiqueta PRs de Dependabot para revisiÃ³n manual
  # =========================================================================
  manage-dependabot:
    name: Manage Dependabot PRs
    runs-on: ubuntu-latest
    needs: analyze-prs
    if: needs.analyze-prs.outputs.dependabot-prs != '[]'
    
    steps:
      - name: Label Dependabot PRs for elite review
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const dependabotPrs = JSON.parse('${{ needs.analyze-prs.outputs.dependabot-prs }}');
            
            console.log('ðŸ¤– Managing Dependabot PRs...');
            console.log(`ðŸ“Š Total Dependabot PRs: ${dependabotPrs.length}`);
            
            for (const pr of dependabotPrs) {
              try {
                console.log(`\nðŸ·ï¸  Processing PR #${pr.number}: ${pr.title}`);
                
                if (!isDryRun) {
                  // Crear etiqueta si no existe
                  try {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: 'elite-review',
                      color: 'FFD700',
                      description: 'Requires elite-level review before merge'
                    });
                    console.log('   âœ… Label "elite-review" created');
                  } catch (error) {
                    if (error.status !== 422) { // 422 = label ya existe
                      console.log(`   âš ï¸  Label creation warning: ${error.message}`);
                    }
                  }
                  
                  // Agregar etiqueta al PR
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    labels: ['elite-review']
                  });
                  
                  // Agregar comentario de auditorÃ­a
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: `ðŸ¤– **Imperial Cleaner - Dependabot Detection**\n\n` +
                          `This PR has been automatically tagged with \`elite-review\` label as it comes from Dependabot.\n\n` +
                          `**Required Actions:**\n` +
                          `- ðŸ‘ï¸  Manual security review required\n` +
                          `- ðŸ“Š Verify dependency compatibility\n` +
                          `- âœ… Approve after thorough testing\n\n` +
                          `**Audit Trail:**\n` +
                          `- Timestamp: ${new Date().toISOString()}\n` +
                          `- Workflow: ${context.workflow}\n` +
                          `- Run ID: ${context.runId}\n` +
                          `- Triggered by: ${context.eventName}`
                  });
                  
                  console.log('   âœ… Label and audit comment added');
                } else {
                  console.log('   ðŸ” [DRY RUN] Would add elite-review label');
                }
              } catch (error) {
                console.error(`   âŒ Error processing PR #${pr.number}: ${error.message}`);
                core.setFailed(`Failed to process Dependabot PR #${pr.number}`);
              }
            }
            
            console.log('\nâœ… Dependabot PR management completed');

  # =========================================================================
  # JOB: Cierre AutomÃ¡tico de PRs
  # Cierra PRs que cumplen criterios de limpieza
  # =========================================================================
  close-prs:
    name: Close Stale/Unwanted PRs
    runs-on: ubuntu-latest
    needs: analyze-prs
    if: needs.analyze-prs.outputs.prs-to-close != '[]'
    
    steps:
      - name: Close PRs with audit trail
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const prsToClose = JSON.parse('${{ needs.analyze-prs.outputs.prs-to-close }}');
            
            console.log('ðŸ—‘ï¸  Closing stale/unwanted PRs...');
            console.log(`ðŸ“Š Total PRs to close: ${prsToClose.length}`);
            
            for (const pr of prsToClose) {
              try {
                console.log(`\nâŒ Closing PR #${pr.number}: ${pr.title}`);
                console.log(`   Reason: ${pr.reason}`);
                console.log(`   Inactive for: ${pr.inactive_hours} hours`);
                
                if (!isDryRun) {
                  // Agregar comentario de auditorÃ­a antes de cerrar
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: `ðŸ”’ **Imperial Cleaner - Automatic Closure**\n\n` +
                          `This Pull Request has been automatically closed by the Imperial Cleaner workflow.\n\n` +
                          `**Closure Reason:**\n` +
                          `${pr.reason}\n\n` +
                          `**Statistics:**\n` +
                          `- Last activity: ${pr.inactive_hours} hours ago\n` +
                          `- Closure threshold: 72 hours of inactivity\n\n` +
                          `**Next Steps:**\n` +
                          `If you believe this closure was inappropriate, you can:\n` +
                          `1. Reopen this PR if you're ready to continue work\n` +
                          `2. Contact the repository maintainers for assistance\n` +
                          `3. Create a new PR with updated changes\n\n` +
                          `**Audit Trail:**\n` +
                          `- Timestamp: ${new Date().toISOString()}\n` +
                          `- Workflow: ${context.workflow}\n` +
                          `- Run ID: ${context.runId}\n` +
                          `- Triggered by: ${context.eventName}\n\n` +
                          `_This is an automated action. For questions, please review the Imperial Cleaner workflow documentation._`
                  });
                  
                  // Cerrar el PR
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    state: 'closed'
                  });
                  
                  console.log(`   âœ… PR #${pr.number} closed successfully`);
                } else {
                  console.log(`   ðŸ” [DRY RUN] Would close PR #${pr.number}`);
                }
              } catch (error) {
                console.error(`   âŒ Error closing PR #${pr.number}: ${error.message}`);
                // No fallar el workflow completo si uno falla
                console.log('   âš ï¸  Continuing with next PR...');
              }
            }
            
            console.log('\nâœ… PR closure process completed');

  # =========================================================================
  # JOB: FusiÃ³n AutomÃ¡tica de PRs
  # Fusiona PRs que cumplen todos los criterios de calidad
  # =========================================================================
  merge-prs:
    name: Auto-merge Ready PRs
    runs-on: ubuntu-latest
    needs: analyze-prs
    if: needs.analyze-prs.outputs.prs-to-merge != '[]'
    
    steps:
      - name: Merge PRs with audit trail
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            const prsToMerge = JSON.parse('${{ needs.analyze-prs.outputs.prs-to-merge }}');
            
            console.log('ðŸ”€ Auto-merging ready PRs...');
            console.log(`ðŸ“Š Total PRs to merge: ${prsToMerge.length}`);
            
            for (const pr of prsToMerge) {
              try {
                console.log(`\nâœ… Merging PR #${pr.number}: ${pr.title}`);
                console.log(`   Author: ${pr.author}`);
                console.log(`   SHA: ${pr.sha}`);
                
                if (!isDryRun) {
                  // Agregar comentario de auditorÃ­a antes de fusionar
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: `ðŸš€ **Imperial Cleaner - Automatic Merge**\n\n` +
                          `This Pull Request has been automatically merged by the Imperial Cleaner workflow.\n\n` +
                          `**Merge Criteria Met:**\n` +
                          `- âœ… All CI/CD checks passed\n` +
                          `- âœ… Not in draft state\n` +
                          `- âœ… Not from Dependabot (requires manual review)\n` +
                          `- âœ… No merge conflicts\n` +
                          `- âœ… All required reviews approved\n\n` +
                          `**Audit Trail:**\n` +
                          `- Timestamp: ${new Date().toISOString()}\n` +
                          `- Commit SHA: ${pr.sha}\n` +
                          `- Workflow: ${context.workflow}\n` +
                          `- Run ID: ${context.runId}\n` +
                          `- Triggered by: ${context.eventName}\n\n` +
                          `_This is an automated merge following enterprise quality standards._`
                  });
                  
                  // Fusionar el PR usando merge commit
                  const mergeResult = await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: pr.number,
                    commit_title: `Auto-merge: ${pr.title} (#${pr.number})`,
                    commit_message: `Automatically merged by Imperial Cleaner workflow.\n\n` +
                                   `All quality checks passed and PR was ready for integration.\n` +
                                   `Audit Trail: Run ID ${context.runId}`,
                    sha: pr.sha,
                    merge_method: 'merge'  // Usar merge commit para trazabilidad completa
                  });
                  
                  console.log(`   âœ… PR #${pr.number} merged successfully`);
                  console.log(`   Merge SHA: ${mergeResult.data.sha}`);
                } else {
                  console.log(`   ðŸ” [DRY RUN] Would merge PR #${pr.number}`);
                }
              } catch (error) {
                console.error(`   âŒ Error merging PR #${pr.number}: ${error.message}`);
                
                // Agregar comentario explicando el fallo
                if (!isDryRun) {
                  try {
                    await github.rest.issues.createComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: pr.number,
                      body: `âš ï¸ **Imperial Cleaner - Auto-merge Failed**\n\n` +
                            `Attempted automatic merge failed. This may be due to:\n` +
                            `- Branch protection rules requiring additional approvals\n` +
                            `- Last-minute check failures\n` +
                            `- Merge conflicts that appeared after analysis\n\n` +
                            `**Error:** ${error.message}\n\n` +
                            `Please review and merge manually if appropriate.`
                    });
                  } catch (commentError) {
                    console.error(`   âŒ Failed to add error comment: ${commentError.message}`);
                  }
                }
                
                // No fallar el workflow completo si uno falla
                console.log('   âš ï¸  Continuing with next PR...');
              }
            }
            
            console.log('\nâœ… PR merge process completed');

  # =========================================================================
  # JOB: Resumen y NotificaciÃ³n
  # Genera un resumen de todas las acciones realizadas
  # =========================================================================
  summary:
    name: Generate Execution Summary
    runs-on: ubuntu-latest
    needs: [analyze-prs, manage-dependabot, close-prs, merge-prs]
    if: always()  # Ejecutar siempre para mostrar resumen
    
    steps:
      - name: Generate workflow summary
        uses: actions/github-script@v7
        with:
          script: |
            const isDryRun = '${{ github.event.inputs.dry_run }}' === 'true';
            
            console.log('ðŸ“‹ Generating Imperial Cleaner execution summary...');
            
            const prsToClose = JSON.parse('${{ needs.analyze-prs.outputs.prs-to-close }}' || '[]');
            const prsToMerge = JSON.parse('${{ needs.analyze-prs.outputs.prs-to-merge }}' || '[]');
            const dependabotPrs = JSON.parse('${{ needs.analyze-prs.outputs.dependabot-prs }}' || '[]');
            
            const summary = `
            # ðŸ° Imperial Cleaner - Execution Summary
            
            **Execution Mode:** ${isDryRun ? 'ðŸ” DRY RUN (no changes made)' : 'âœ… PRODUCTION'}
            **Timestamp:** ${new Date().toISOString()}
            **Workflow Run:** [#${context.runId}](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
            **Triggered by:** ${context.eventName}
            
            ## ðŸ“Š Actions Summary
            
            | Action | Count | Status |
            |--------|-------|--------|
            | PRs Closed | ${prsToClose.length} | ${{ needs.close-prs.result }} |
            | PRs Merged | ${prsToMerge.length} | ${{ needs.merge-prs.result }} |
            | Dependabot PRs Tagged | ${dependabotPrs.length} | ${{ needs.manage-dependabot.result }} |
            
            ## ðŸ—‘ï¸ Closed PRs
            
            ${prsToClose.length > 0 ? prsToClose.map(pr => 
              `- PR #${pr.number}: ${pr.title}\n  - **Reason:** ${pr.reason}\n  - **Inactive:** ${pr.inactive_hours}h`
            ).join('\n') : '_No PRs closed_'}
            
            ## ðŸ”€ Merged PRs
            
            ${prsToMerge.length > 0 ? prsToMerge.map(pr => 
              `- PR #${pr.number}: ${pr.title}\n  - **Author:** ${pr.author}`
            ).join('\n') : '_No PRs merged_'}
            
            ## ðŸ¤– Dependabot PRs
            
            ${dependabotPrs.length > 0 ? dependabotPrs.map(pr => 
              `- PR #${pr.number}: ${pr.title}\n  - **Tagged:** elite-review`
            ).join('\n') : '_No Dependabot PRs found_'}
            
            ## ðŸ“ˆ Workflow Health
            
            - **Analysis:** ${{ needs.analyze-prs.result }}
            - **Dependabot Management:** ${{ needs.manage-dependabot.result }}
            - **PR Closure:** ${{ needs.close-prs.result }}
            - **PR Merge:** ${{ needs.merge-prs.result }}
            
            ---
            
            _Imperial Cleaner - Enterprise Premium PR Management_
            `;
            
            await core.summary
              .addRaw(summary)
              .write();
            
            console.log('âœ… Summary generated successfully');
            console.log('\n' + '='.repeat(60));
            console.log('ðŸŽ‰ Imperial Cleaner execution completed!');
            console.log('='.repeat(60));
