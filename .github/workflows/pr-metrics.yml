name: ðŸ“ˆ PR Metrics Comment

# Post comprehensive metrics about pull requests
# Analyzes complexity, size, test coverage, and quality scores

on:
  pull_request:
    types: [opened, synchronize, reopened]

# Minimal permissions
permissions:
  contents: read
  pull-requests: write

jobs:
  pr-metrics:
    name: Calculate and Post PR Metrics
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for better analysis
      
      - name: Get PR files and calculate metrics
        id: metrics
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            
            // Get list of files changed
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
            });
            
            // Calculate metrics
            const additions = pr.additions || 0;
            const deletions = pr.deletions || 0;
            const totalChanges = additions + deletions;
            const filesChanged = files.length;
            
            // Categorize files by type
            const fileTypes = {
              go: 0,
              python: 0,
              typescript: 0,
              javascript: 0,
              dart: 0,
              yaml: 0,
              markdown: 0,
              sql: 0,
              other: 0
            };
            
            const testFiles = [];
            const configFiles = [];
            
            for (const file of files) {
              const filename = file.filename;
              const ext = filename.split('.').pop();
              
              // Count by type
              if (ext === 'go') fileTypes.go++;
              else if (ext === 'py') fileTypes.python++;
              else if (ext === 'ts' || ext === 'tsx') fileTypes.typescript++;
              else if (ext === 'js' || ext === 'jsx') fileTypes.javascript++;
              else if (ext === 'dart') fileTypes.dart++;
              else if (ext === 'yml' || ext === 'yaml') fileTypes.yaml++;
              else if (ext === 'md') fileTypes.markdown++;
              else if (ext === 'sql') fileTypes.sql++;
              else fileTypes.other++;
              
              // Identify test files
              if (filename.includes('_test.go') || 
                  filename.includes('test_') || 
                  filename.includes('.test.') || 
                  filename.includes('.spec.')) {
                testFiles.push(filename);
              }
              
              // Identify config files
              if (filename.includes('config') || 
                  filename.includes('.yml') || 
                  filename.includes('.yaml') ||
                  filename.includes('.json') ||
                  filename.includes('.toml')) {
                configFiles.push(filename);
              }
            }
            
            // Calculate complexity score (XS, S, M, L, XL)
            let complexity;
            let complexityEmoji;
            let reviewTimeMinutes;
            
            if (totalChanges < 10) {
              complexity = 'XS';
              complexityEmoji = 'ðŸŸ¢';
              reviewTimeMinutes = 5;
            } else if (totalChanges < 50) {
              complexity = 'S';
              complexityEmoji = 'ðŸŸ¢';
              reviewTimeMinutes = 15;
            } else if (totalChanges < 250) {
              complexity = 'M';
              complexityEmoji = 'ðŸŸ¡';
              reviewTimeMinutes = 30;
            } else if (totalChanges < 500) {
              complexity = 'L';
              complexityEmoji = 'ðŸŸ ';
              reviewTimeMinutes = 60;
            } else {
              complexity = 'XL';
              complexityEmoji = 'ðŸ”´';
              reviewTimeMinutes = 120;
            }
            
            // Calculate test coverage indicator
            const hasTests = testFiles.length > 0;
            const testRatio = filesChanged > 0 ? (testFiles.length / filesChanged) : 0;
            let testCoverage;
            
            if (testRatio >= 0.3) {
              testCoverage = 'ðŸŸ¢ Good';
            } else if (testRatio >= 0.1) {
              testCoverage = 'ðŸŸ¡ Fair';
            } else if (hasTests) {
              testCoverage = 'ðŸŸ  Low';
            } else {
              testCoverage = 'ðŸ”´ None';
            }
            
            // Calculate quality score
            let qualityScore = 100;
            
            // Penalties
            if (totalChanges > 500) qualityScore -= 20;
            else if (totalChanges > 250) qualityScore -= 10;
            
            if (!hasTests) qualityScore -= 20;
            else if (testRatio < 0.1) qualityScore -= 10;
            
            if (filesChanged > 30) qualityScore -= 15;
            else if (filesChanged > 15) qualityScore -= 5;
            
            // Bonuses
            if (fileTypes.markdown > 0 && fileTypes.markdown < filesChanged) qualityScore += 5;
            if (hasTests && testRatio >= 0.3) qualityScore += 10;
            if (totalChanges < 50 && filesChanged < 5) qualityScore += 10;
            
            qualityScore = Math.max(0, Math.min(100, qualityScore));
            
            let qualityEmoji;
            if (qualityScore >= 90) qualityEmoji = 'ðŸŸ¢';
            else if (qualityScore >= 70) qualityEmoji = 'ðŸŸ¡';
            else qualityEmoji = 'ðŸ”´';
            
            // Store outputs
            const metricsData = {
              additions,
              deletions,
              totalChanges,
              filesChanged,
              fileTypes,
              testFiles: testFiles.length,
              configFiles: configFiles.length,
              complexity,
              complexityEmoji,
              reviewTimeMinutes,
              testCoverage,
              qualityScore,
              qualityEmoji,
              hasTests
            };
            
            core.setOutput('metrics', JSON.stringify(metricsData));
            return metricsData;
      
      - name: Post metrics comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const metrics = JSON.parse('${{ steps.metrics.outputs.metrics }}');
            
            // Build metrics table
            let body = `## ðŸ“ˆ Pull Request Metrics\n\n`;
            
            // Summary table
            body += `### ðŸ“Š Summary\n\n`;
            body += `| Metric | Value |\n`;
            body += `|--------|-------|\n`;
            body += `| **Size** | ${metrics.complexityEmoji} ${metrics.complexity} (${metrics.totalChanges} changes) |\n`;
            body += `| **Lines Added** | +${metrics.additions} |\n`;
            body += `| **Lines Deleted** | -${metrics.deletions} |\n`;
            body += `| **Files Changed** | ${metrics.filesChanged} |\n`;
            body += `| **Test Coverage** | ${metrics.testCoverage} (${metrics.testFiles} test files) |\n`;
            body += `| **Quality Score** | ${metrics.qualityEmoji} ${metrics.qualityScore}/100 |\n`;
            body += `| **Est. Review Time** | ~${metrics.reviewTimeMinutes} min |\n\n`;
            
            // File breakdown
            body += `### ðŸ“ Files by Type\n\n`;
            body += `| Language | Count |\n`;
            body += `|----------|-------|\n`;
            if (metrics.fileTypes.go > 0) body += `| ðŸ¹ Go | ${metrics.fileTypes.go} |\n`;
            if (metrics.fileTypes.python > 0) body += `| ðŸ Python | ${metrics.fileTypes.python} |\n`;
            if (metrics.fileTypes.typescript > 0) body += `| ðŸ“˜ TypeScript | ${metrics.fileTypes.typescript} |\n`;
            if (metrics.fileTypes.javascript > 0) body += `| ðŸ“œ JavaScript | ${metrics.fileTypes.javascript} |\n`;
            if (metrics.fileTypes.dart > 0) body += `| ðŸŽ¯ Dart | ${metrics.fileTypes.dart} |\n`;
            if (metrics.fileTypes.yaml > 0) body += `| âš™ï¸ YAML | ${metrics.fileTypes.yaml} |\n`;
            if (metrics.fileTypes.markdown > 0) body += `| ðŸ“ Markdown | ${metrics.fileTypes.markdown} |\n`;
            if (metrics.fileTypes.sql > 0) body += `| ðŸ—„ï¸ SQL | ${metrics.fileTypes.sql} |\n`;
            if (metrics.fileTypes.other > 0) body += `| ðŸ“„ Other | ${metrics.fileTypes.other} |\n`;
            body += `\n`;
            
            // Recommendations
            body += `### ðŸ’¡ Recommendations\n\n`;
            
            if (metrics.complexity === 'XL') {
              body += `- âš ï¸ **Large PR**: Consider breaking this into smaller PRs for easier review\n`;
            }
            
            if (!metrics.hasTests) {
              body += `- âš ï¸ **No Tests**: Add unit tests to verify functionality\n`;
            } else if (metrics.testCoverage.includes('Low') || metrics.testCoverage.includes('Fair')) {
              body += `- ðŸ’¡ **Test Coverage**: Consider adding more tests\n`;
            }
            
            if (metrics.filesChanged > 30) {
              body += `- âš ï¸ **Many Files**: ${metrics.filesChanged} files changed. Consider splitting if possible.\n`;
            }
            
            if (metrics.qualityScore >= 90) {
              body += `- âœ… **Excellent Quality**: This PR meets high quality standards!\n`;
            } else if (metrics.qualityScore >= 70) {
              body += `- âœ… **Good Quality**: This PR is well-structured\n`;
            } else {
              body += `- ðŸ”§ **Needs Improvement**: Review the suggestions above\n`;
            }
            
            body += `\n`;
            
            // Tips
            body += `---\n`;
            body += `ðŸ’¡ **Pro Tips**:\n`;
            body += `- Keep PRs small and focused (< 250 lines)\n`;
            body += `- Include tests for new functionality\n`;
            body += `- Update documentation as needed\n`;
            body += `- Respond to review comments promptly\n`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ðŸ“ˆ Pull Request Metrics')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: body
              });
            }
            
            // Add to step summary
            core.summary
              .addHeading('ðŸ“ˆ PR Metrics')
              .addRaw(`Complexity: ${metrics.complexity} | Quality: ${metrics.qualityScore}/100`)
              .write();
