name: ðŸ·ï¸ PR Auto-Labeler

# Automatically label PRs by size, type, and language
# Reads configuration from .github/pr-automation-config.yml

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches:
      - Main
      - main
      - develop
      - 'feature/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  label-pr:
    name: Label PR
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Load configuration
        id: config
        run: |
          if [ -f .github/pr-automation-config.yml ]; then
            echo "config_exists=true" >> $GITHUB_OUTPUT
          else
            echo "config_exists=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Auto-label PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');
            
            console.log('ðŸ·ï¸  Starting PR auto-labeling...');
            
            // Load configuration
            let config;
            try {
              const configFile = fs.readFileSync('.github/pr-automation-config.yml', 'utf8');
              config = yaml.load(configFile);
              console.log('âœ… Configuration loaded successfully');
            } catch (error) {
              console.error('âŒ Failed to load configuration:', error);
              config = { auto_labels: {} };
            }
            
            const prNumber = context.payload.pull_request.number;
            const pr = context.payload.pull_request;
            
            console.log(`Processing PR #${prNumber}: ${pr.title}`);
            
            // Get PR files and calculate changes
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              per_page: 100
            });
            
            const totalChanges = files.data.reduce((sum, file) => sum + file.additions + file.deletions, 0);
            const changedFiles = files.data.map(f => f.filename);
            
            console.log(`Total changes: ${totalChanges} lines`);
            console.log(`Files changed: ${changedFiles.length}`);
            
            const labelsToAdd = [];
            const labelsToRemove = [];
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SIZE LABELS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const sizeLabels = config.auto_labels?.size || [
              { label: 'size/XS', min_lines: 0, max_lines: 10 },
              { label: 'size/S', min_lines: 11, max_lines: 100 },
              { label: 'size/M', min_lines: 101, max_lines: 500 },
              { label: 'size/L', min_lines: 501, max_lines: 1000 },
              { label: 'size/XL', min_lines: 1001, max_lines: 5000 },
              { label: 'size/XXL', min_lines: 5001, max_lines: 999999 }
            ];
            
            let sizeLabel = null;
            for (const size of sizeLabels) {
              if (totalChanges >= size.min_lines && totalChanges <= size.max_lines) {
                sizeLabel = size.label;
                labelsToAdd.push(size.label);
                break;
              }
            }
            
            // Remove other size labels
            const allSizeLabels = sizeLabels.map(s => s.label);
            allSizeLabels.forEach(label => {
              if (label !== sizeLabel) {
                labelsToRemove.push(label);
              }
            });
            
            console.log(`ðŸ“ Size: ${sizeLabel} (${totalChanges} lines)`);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPE LABELS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const typeRules = config.auto_labels?.type || [
              { label: 'type/documentation', paths: ['**/*.md', 'docs/**'] },
              { label: 'type/tests', paths: ['**/*_test.go', '**/*_test.py', 'tests/**'] },
              { label: 'type/ci-cd', paths: ['.github/workflows/**', '.github/actions/**'] },
              { label: 'type/agents', paths: ['agents/**', '.github/agents/**'] },
              { label: 'type/infrastructure', paths: ['infrastructure/**', 'terraform/**', 'k8s/**'] }
            ];
            
            const matchPath = (filename, patterns) => {
              return patterns.some(pattern => {
                const regex = new RegExp('^' + pattern.replace(/\*\*/g, '.*').replace(/\*/g, '[^/]*') + '$');
                return regex.test(filename);
              });
            };
            
            for (const rule of typeRules) {
              if (changedFiles.some(file => matchPath(file, rule.paths))) {
                labelsToAdd.push(rule.label);
                console.log(`ðŸ·ï¸  Type: ${rule.label}`);
              }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LANGUAGE LABELS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const langRules = config.auto_labels?.language || [
              { label: 'lang/go', paths: ['**/*.go'] },
              { label: 'lang/python', paths: ['**/*.py'] },
              { label: 'lang/javascript', paths: ['**/*.js', '**/*.ts'] },
              { label: 'lang/kotlin', paths: ['**/*.kt'] },
              { label: 'lang/shell', paths: ['**/*.sh'] }
            ];
            
            for (const rule of langRules) {
              if (changedFiles.some(file => matchPath(file, rule.paths))) {
                labelsToAdd.push(rule.label);
                console.log(`ðŸ’» Language: ${rule.label}`);
              }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // APPLY LABELS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Get current labels
            const currentLabels = pr.labels.map(l => l.name);
            
            // Add new labels
            const uniqueLabelsToAdd = [...new Set(labelsToAdd)].filter(l => !currentLabels.includes(l));
            if (uniqueLabelsToAdd.length > 0) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  labels: uniqueLabelsToAdd
                });
                console.log(`âœ… Added labels: ${uniqueLabelsToAdd.join(', ')}`);
              } catch (error) {
                console.error('âŒ Failed to add labels:', error.message);
              }
            }
            
            // Remove old labels
            for (const label of labelsToRemove) {
              if (currentLabels.includes(label)) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    name: label
                  });
                  console.log(`ðŸ—‘ï¸  Removed label: ${label}`);
                } catch (error) {
                  // Label might not exist, that's ok
                }
              }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // XXL WARNING COMMENT
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (sizeLabel === 'size/XXL') {
              const warningComment = '## âš ï¸ PR Size Warning\n\n' +
                'This PR is **XXL** (' + totalChanges + ' lines changed). Consider splitting it into smaller PRs for easier review.\n\n' +
                '**Benefits of smaller PRs:**\n' +
                '- âœ… Faster review cycles\n' +
                '- âœ… Easier to identify issues\n' +
                '- âœ… Lower risk of merge conflicts\n' +
                '- âœ… Better for incremental testing\n\n' +
                '**Suggested approach:**\n' +
                '1. Identify logical components or features\n' +
                '2. Create separate PRs for each component\n' +
                '3. Link them together with references\n\n' +
                'If this PR cannot be split, please add a comment explaining why.';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: warningComment
              });
              
              console.log('âš ï¸  XXL warning comment posted');
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SUMMARY
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            core.summary
              .addHeading('ðŸ·ï¸ PR Auto-Labeling Complete', 2)
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Value', header: true}],
                ['PR Number', `#${prNumber}`],
                ['Size', `${sizeLabel} (${totalChanges} lines)`],
                ['Files Changed', `${changedFiles.length}`],
                ['Labels Added', uniqueLabelsToAdd.length > 0 ? uniqueLabelsToAdd.join(', ') : 'None'],
                ['Labels Removed', labelsToRemove.length > 0 ? labelsToRemove.join(', ') : 'None']
              ])
              .write();
            
            console.log('âœ… PR auto-labeling completed successfully');
